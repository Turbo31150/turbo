<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>JARVIS WhisperFlow</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --bg: #0a0e14;
    --surface: #131920;
    --surface2: #1a2230;
    --accent: #ff6b35;
    --accent2: #ff8c5a;
    --green: #00e676;
    --red: #ff5252;
    --blue: #448aff;
    --purple: #b388ff;
    --text: #e0e0e0;
    --dim: #6b7d93;
    --border: #1e2d3d;
  }

  body {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: var(--bg);
    color: var(--text);
    overflow: hidden;
    user-select: none;
    height: 100vh;
  }

  /* HEADER — draggable title bar */
  .header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 12px;
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    -webkit-app-region: drag;
    cursor: move;
  }
  .header-left { display: flex; align-items: center; gap: 8px; }
  .logo {
    width: 20px; height: 20px;
    background: var(--accent);
    border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    font-size: 10px; font-weight: bold; color: #fff;
  }
  .title { font-size: 12px; font-weight: 600; letter-spacing: 0.5px; }
  .title span { color: var(--accent); }
  .header-right { display: flex; gap: 4px; -webkit-app-region: no-drag; }
  .header-btn {
    width: 24px; height: 24px;
    border: none; background: transparent;
    color: var(--dim); cursor: pointer;
    border-radius: 4px; font-size: 14px;
    display: flex; align-items: center; justify-content: center;
  }
  .header-btn:hover { background: var(--surface2); color: var(--text); }

  /* STATUS BAR */
  .status-bar {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 4px 12px;
    background: var(--surface);
    font-size: 10px;
    color: var(--dim);
    border-bottom: 1px solid var(--border);
  }
  .status-dot {
    width: 6px; height: 6px;
    border-radius: 50%;
    background: var(--green);
    flex-shrink: 0;
  }
  .status-dot.offline { background: var(--red); }
  .status-dot.connecting { background: #ffab40; animation: pulse 1s infinite; }
  @keyframes pulse { 50% { opacity: 0.3; } }

  /* MAIN CONTENT */
  .main {
    display: flex;
    flex-direction: column;
    height: calc(100vh - 72px);
    padding: 10px;
    gap: 10px;
  }

  /* TRANSCRIPTION ZONE */
  .transcript-zone {
    flex: 1;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 10px;
    overflow-y: auto;
    min-height: 80px;
  }
  .transcript-zone::-webkit-scrollbar { width: 4px; }
  .transcript-zone::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
  .transcript-text {
    font-size: 13px;
    line-height: 1.5;
    color: var(--text);
    white-space: pre-wrap;
    word-break: break-word;
  }
  .transcript-text.listening {
    color: var(--accent2);
    animation: textpulse 1.5s ease-in-out infinite;
  }
  @keyframes textpulse { 50% { opacity: 0.6; } }
  .transcript-text.processing { color: var(--blue); }
  .transcript-placeholder {
    color: var(--dim);
    font-style: italic;
    font-size: 12px;
    text-align: center;
    padding-top: 20px;
  }

  /* DOMINO RESULT */
  .domino-result {
    background: var(--surface2);
    border: 1px solid var(--accent);
    border-radius: 6px;
    padding: 8px 10px;
    margin-top: 6px;
    font-size: 11px;
    display: none;
  }
  .domino-result.show { display: block; }
  .domino-name { color: var(--accent); font-weight: 600; }
  .domino-cat { color: var(--dim); margin-left: 6px; }
  .domino-steps { color: var(--green); margin-top: 2px; font-size: 10px; }

  /* JARVIS RESPONSE */
  .jarvis-response {
    background: linear-gradient(135deg, var(--surface2), rgba(255,107,53,0.05));
    border-left: 3px solid var(--accent);
    border-radius: 0 6px 6px 0;
    padding: 8px 10px;
    margin-top: 6px;
    font-size: 12px;
    line-height: 1.5;
    display: none;
    white-space: pre-wrap;
    word-break: break-word;
    max-height: 120px;
    overflow-y: auto;
  }
  .jarvis-response.show { display: block; }
  .jarvis-response .jr-label {
    color: var(--accent);
    font-weight: 600;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 3px;
  }
  .jarvis-response .jr-text { color: var(--text); }
  .jarvis-response.thinking {
    color: var(--blue);
    animation: textpulse 1.5s ease-in-out infinite;
  }

  /* HISTORY */
  .history {
    max-height: 100px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 3px;
  }
  .history-item {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 3px 8px;
    background: var(--surface);
    border-radius: 4px;
    font-size: 10px;
    cursor: pointer;
  }
  .history-item:hover { background: var(--surface2); }
  .history-time { color: var(--dim); min-width: 40px; }
  .history-text { color: var(--text); flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  .history-domino { color: var(--accent); font-weight: 500; }

  /* CONTROLS */
  .controls {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  /* MIC BUTTON */
  .mic-btn {
    width: 48px; height: 48px;
    border-radius: 50%;
    border: 2px solid var(--accent);
    background: transparent;
    color: var(--accent);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 22px;
    transition: all 0.2s;
    flex-shrink: 0;
    position: relative;
  }
  .mic-btn:hover { background: rgba(255,107,53,0.1); transform: scale(1.05); }
  .mic-btn.recording {
    background: var(--accent);
    color: #fff;
    border-color: var(--accent);
    animation: mic-pulse 1s ease-in-out infinite;
    box-shadow: 0 0 20px rgba(255,107,53,0.4);
  }
  @keyframes mic-pulse {
    0%, 100% { box-shadow: 0 0 10px rgba(255,107,53,0.3); }
    50% { box-shadow: 0 0 25px rgba(255,107,53,0.6); }
  }
  .mic-btn.processing {
    border-color: var(--blue);
    color: var(--blue);
    animation: spin 1s linear infinite;
  }
  @keyframes spin { 100% { transform: rotate(360deg); } }

  /* VISUALIZER */
  .visualizer {
    display: flex;
    align-items: center;
    gap: 2px;
    height: 32px;
    flex: 1;
  }
  .viz-bar {
    width: 3px;
    background: var(--accent);
    border-radius: 2px;
    transition: height 0.08s ease;
    min-height: 3px;
  }

  /* TEXT INPUT */
  .text-input-wrap {
    display: flex;
    gap: 6px;
    align-items: center;
  }
  .text-input {
    flex: 1;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 6px 10px;
    color: var(--text);
    font-size: 12px;
    outline: none;
    font-family: inherit;
  }
  .text-input:focus { border-color: var(--accent); }
  .text-input::placeholder { color: var(--dim); }
  .send-btn {
    width: 30px; height: 30px;
    border: none;
    background: var(--accent);
    color: #fff;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    display: flex; align-items: center; justify-content: center;
  }
  .send-btn:hover { background: var(--accent2); }

  /* CLUSTER MINI */
  .cluster-mini {
    display: flex;
    gap: 4px;
    margin-left: auto;
    flex-shrink: 0;
  }
  .node-dot {
    display: flex;
    align-items: center;
    gap: 3px;
    font-size: 9px;
    color: var(--dim);
    padding: 2px 5px;
    background: var(--surface);
    border-radius: 3px;
  }
  .node-dot .dot {
    width: 5px; height: 5px;
    border-radius: 50%;
    background: var(--green);
  }
  .node-dot .dot.off { background: var(--red); }

  /* MODE TOGGLE */
  .mode-toggle {
    display: flex;
    gap: 2px;
    background: var(--surface);
    border-radius: 4px;
    padding: 2px;
  }
  .mode-btn {
    padding: 3px 8px;
    border: none;
    background: transparent;
    color: var(--dim);
    border-radius: 3px;
    font-size: 10px;
    cursor: pointer;
  }
  .mode-btn.active { background: var(--accent); color: #fff; }
  .mode-btn:hover:not(.active) { color: var(--text); }

  /* SHORTCUTS HINT */
  .shortcuts {
    text-align: center;
    font-size: 9px;
    color: var(--dim);
    padding: 2px;
  }
  kbd {
    background: var(--surface2);
    padding: 1px 4px;
    border-radius: 2px;
    border: 1px solid var(--border);
    font-size: 9px;
  }

  /* SETTINGS PANEL */
  .settings-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.6);
    z-index: 100;
    display: none;
    align-items: center;
    justify-content: center;
  }
  .settings-overlay.open { display: flex; }
  .settings-panel {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 10px;
    width: 320px;
    max-height: 80vh;
    overflow-y: auto;
    padding: 16px;
  }
  .settings-title {
    font-size: 14px;
    font-weight: 600;
    color: var(--accent);
    margin-bottom: 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .settings-close {
    background: none; border: none; color: var(--dim);
    cursor: pointer; font-size: 18px;
  }
  .settings-close:hover { color: var(--text); }
  .settings-group {
    margin-bottom: 12px;
  }
  .settings-group label {
    display: block;
    font-size: 11px;
    color: var(--dim);
    margin-bottom: 4px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .settings-group select,
  .settings-group input[type="text"],
  .settings-group input[type="number"] {
    width: 100%;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 6px 8px;
    color: var(--text);
    font-size: 12px;
    font-family: inherit;
    outline: none;
  }
  .settings-group select:focus,
  .settings-group input:focus { border-color: var(--accent); }
  .settings-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 0;
  }
  .settings-row span { font-size: 12px; }
  .toggle-switch {
    width: 36px; height: 18px;
    background: var(--border);
    border-radius: 9px;
    position: relative;
    cursor: pointer;
    transition: background 0.2s;
  }
  .toggle-switch.on { background: var(--accent); }
  .toggle-switch::after {
    content: '';
    width: 14px; height: 14px;
    background: #fff;
    border-radius: 50%;
    position: absolute;
    top: 2px; left: 2px;
    transition: left 0.2s;
  }
  .toggle-switch.on::after { left: 20px; }
  .settings-info {
    font-size: 10px;
    color: var(--dim);
    margin-top: 10px;
    padding-top: 8px;
    border-top: 1px solid var(--border);
  }

  /* ── DICTIONARY PANEL ───────────────────────────────────── */
  .dict-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.7);
    z-index: 200;
    display: none;
    align-items: stretch;
    justify-content: center;
  }
  .dict-overlay.open { display: flex; }
  .dict-panel {
    background: var(--bg);
    width: 100%;
    max-width: 700px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  .dict-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 12px;
    background: var(--surface);
    border-bottom: 1px solid var(--border);
  }
  .dict-header .dict-title {
    font-size: 13px;
    font-weight: 600;
    color: var(--accent);
    white-space: nowrap;
  }
  .dict-search {
    flex: 1;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 5px;
    padding: 5px 8px;
    color: var(--text);
    font-size: 12px;
    outline: none;
    font-family: inherit;
  }
  .dict-search:focus { border-color: var(--accent); }
  .dict-close {
    background: none; border: none; color: var(--dim);
    cursor: pointer; font-size: 18px; padding: 0 4px;
  }
  .dict-close:hover { color: var(--text); }
  .dict-stats {
    display: flex;
    gap: 6px;
    padding: 6px 12px;
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    flex-wrap: wrap;
  }
  .dict-stat {
    font-size: 10px;
    color: var(--dim);
    padding: 2px 8px;
    background: var(--surface2);
    border-radius: 3px;
  }
  .dict-stat b { color: var(--accent); }
  .dict-tabs {
    display: flex;
    gap: 2px;
    padding: 6px 12px;
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    overflow-x: auto;
  }
  .dict-tab {
    padding: 4px 10px;
    border: none;
    background: transparent;
    color: var(--dim);
    border-radius: 4px;
    font-size: 10px;
    cursor: pointer;
    white-space: nowrap;
    font-family: inherit;
  }
  .dict-tab.active { background: var(--accent); color: #fff; }
  .dict-tab:hover:not(.active) { background: var(--surface2); color: var(--text); }
  .dict-tab .tab-count {
    font-size: 9px;
    opacity: 0.7;
    margin-left: 3px;
  }
  .dict-body {
    flex: 1;
    overflow-y: auto;
    padding: 6px;
  }
  .dict-body::-webkit-scrollbar { width: 5px; }
  .dict-body::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
  .dict-section-title {
    font-size: 11px;
    font-weight: 600;
    color: var(--accent);
    padding: 6px 8px 3px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .dict-item {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 5px 8px;
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.1s;
  }
  .dict-item:hover { background: var(--surface2); }
  .dict-item-icon {
    width: 20px; height: 20px;
    border-radius: 3px;
    display: flex; align-items: center; justify-content: center;
    font-size: 10px; font-weight: bold;
    flex-shrink: 0;
  }
  .dict-item-icon.cmd { background: rgba(68,138,255,0.2); color: var(--blue); }
  .dict-item-icon.pipe { background: rgba(179,136,255,0.2); color: var(--purple); }
  .dict-item-icon.chain { background: rgba(0,230,118,0.2); color: var(--green); }
  .dict-item-icon.corr { background: rgba(255,171,64,0.2); color: #ffab40; }
  .dict-item-info { flex: 1; min-width: 0; }
  .dict-item-name {
    font-size: 11px;
    font-weight: 500;
    color: var(--text);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .dict-item-desc {
    font-size: 9px;
    color: var(--dim);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .dict-item-triggers {
    font-size: 9px;
    color: var(--accent2);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .dict-item-badge {
    font-size: 9px;
    padding: 1px 5px;
    border-radius: 3px;
    background: var(--surface);
    color: var(--dim);
    flex-shrink: 0;
  }
  .dict-item-exec {
    width: 22px; height: 22px;
    border: 1px solid var(--accent);
    background: transparent;
    color: var(--accent);
    border-radius: 3px;
    cursor: pointer;
    font-size: 10px;
    display: flex; align-items: center; justify-content: center;
    flex-shrink: 0;
    opacity: 0;
    transition: opacity 0.15s;
  }
  .dict-item:hover .dict-item-exec { opacity: 1; }
  .dict-item-exec:hover { background: var(--accent); color: #fff; }
  .dict-empty {
    text-align: center;
    color: var(--dim);
    font-size: 12px;
    padding: 30px 10px;
    font-style: italic;
  }
  .dict-loading {
    text-align: center;
    color: var(--blue);
    font-size: 12px;
    padding: 30px 10px;
    animation: textpulse 1.5s ease-in-out infinite;
  }
</style>
</head>
<body>

<div class="header">
  <div class="header-left">
    <div class="logo">J</div>
    <div class="title"><span>JARVIS</span> WhisperFlow</div>
  </div>
  <div class="header-right">
    <button class="header-btn" id="dictBtn" title="Dictionnaire commandes" style="font-size:12px;">&#x1F4D6;</button>
    <button class="header-btn" id="pinBtn" title="Toujours visible">&#x1F4CC;</button>
    <button class="header-btn" id="settingsBtn" title="Parametres">&#x2699;</button>
    <button class="header-btn" id="minimizeBtn" title="Minimiser">&#x2500;</button>
  </div>
</div>

<div class="status-bar">
  <div class="status-dot" id="wsStatus"></div>
  <span id="wsStatusText">Connexion...</span>
  <div class="cluster-mini" id="clusterMini"></div>
</div>

<div class="main">
  <!-- Transcription -->
  <div class="transcript-zone" id="transcriptZone">
    <div class="transcript-placeholder" id="placeholder">
      Appuie sur le micro ou maintiens <kbd>Espace</kbd> pour parler
    </div>
    <div class="transcript-text" id="transcriptText" style="display:none"></div>
    <div class="domino-result" id="dominoResult">
      <span class="domino-name" id="dominoName"></span>
      <span class="domino-cat" id="dominoCat"></span>
      <div class="domino-steps" id="dominoSteps"></div>
    </div>
    <div class="jarvis-response" id="jarvisResponse">
      <div class="jr-label">JARVIS</div>
      <div class="jr-text" id="jarvisText"></div>
    </div>
  </div>

  <!-- History -->
  <div class="history" id="history"></div>

  <!-- Controls -->
  <div class="controls">
    <button class="mic-btn" id="micBtn" title="Enregistrer (Espace)">&#x1F3A4;</button>
    <div class="visualizer" id="visualizer"></div>
    <div class="mode-toggle">
      <button class="mode-btn active" data-mode="ptt">PTT</button>
      <button class="mode-btn" data-mode="wake">Wake</button>
      <button class="mode-btn" data-mode="auto">Auto</button>
    </div>
  </div>

  <!-- Text input -->
  <div class="text-input-wrap">
    <input class="text-input" id="textInput" placeholder="Tape une commande..." />
    <button class="send-btn" id="sendBtn">&#x27A4;</button>
  </div>

  <div class="shortcuts">
    <kbd>Espace</kbd> PTT &nbsp; <kbd>Esc</kbd> Stop &nbsp; <kbd>Enter</kbd> Envoyer texte
  </div>
</div>

<!-- DICTIONARY PANEL -->
<div class="dict-overlay" id="dictOverlay">
  <div class="dict-panel">
    <div class="dict-header">
      <div class="dict-title">DICTIONNAIRE</div>
      <input class="dict-search" id="dictSearch" placeholder="Rechercher commande, pipeline, trigger..." autofocus />
      <button class="dict-close" id="dictClose">&times;</button>
    </div>
    <div class="dict-stats" id="dictStats"></div>
    <div class="dict-tabs" id="dictTabs"></div>
    <div class="dict-body" id="dictBody">
      <div class="dict-loading">Chargement du dictionnaire...</div>
    </div>
  </div>
</div>

<!-- SETTINGS PANEL -->
<div class="settings-overlay" id="settingsOverlay">
  <div class="settings-panel">
    <div class="settings-title">
      Parametres
      <button class="settings-close" id="settingsClose">&times;</button>
    </div>

    <div class="settings-group">
      <label>Backend WebSocket</label>
      <input type="text" id="setWsUrl" value="ws://127.0.0.1:9742/ws" />
    </div>

    <div class="settings-group">
      <label>Whisper Model</label>
      <select id="setWhisperModel">
        <option value="large-v3-turbo" selected>large-v3-turbo (CUDA)</option>
        <option value="large-v3">large-v3</option>
        <option value="medium">medium</option>
        <option value="small">small</option>
      </select>
    </div>

    <div class="settings-group">
      <label>Voix TTS</label>
      <select id="setTtsVoice">
        <option value="fr-FR-HenriNeural" selected>Henri (FR)</option>
        <option value="fr-FR-DeniseNeural">Denise (FR)</option>
        <option value="en-US-GuyNeural">Guy (EN)</option>
        <option value="en-US-JennyNeural">Jenny (EN)</option>
      </select>
    </div>

    <div class="settings-group">
      <label>Options</label>
      <div class="settings-row">
        <span>Correction vocale</span>
        <div class="toggle-switch on" id="toggleCorrection" data-key="correction"></div>
      </div>
      <div class="settings-row">
        <span>Son feedback</span>
        <div class="toggle-switch on" id="toggleSound" data-key="sound"></div>
      </div>
      <div class="settings-row">
        <span>Auto-execute domino</span>
        <div class="toggle-switch" id="toggleAutoExec" data-key="autoExec"></div>
      </div>
      <div class="settings-row">
        <span>Mode silencieux</span>
        <div class="toggle-switch" id="toggleSilent" data-key="silent"></div>
      </div>
    </div>

    <div class="settings-info">
      JARVIS WhisperFlow v1.1<br>
      Backend: FastAPI + Whisper CUDA<br>
      Raccourcis: <kbd>Espace</kbd> PTT | <kbd>Esc</kbd> Stop | <kbd>Ctrl+Shift+W</kbd> Toggle
    </div>
  </div>
</div>

<script>
// ══════════════════════════════════════════════════════════════════
// JARVIS WhisperFlow — Voice-First Overlay Interface
// ══════════════════════════════════════════════════════════════════

// Auto-detect WS URL: same host if served from backend, fallback to localhost
const _loc = window.location;
const WS_URL = (_loc.protocol === 'file:')
  ? 'ws://127.0.0.1:9742/ws'
  : `ws://${_loc.host}/ws`;
const CLUSTER_NODES = {
  M1:  { url: 'http://10.5.0.2:1234/api/v1/models', label: 'M1' },
  M2:  { url: 'http://192.168.1.26:1234/api/v1/models', label: 'M2' },
  OL1: { url: 'http://127.0.0.1:11434/api/tags', label: 'OL1' },
  M3:  { url: 'http://192.168.1.113:1234/api/v1/models', label: 'M3' },
};

// STATE
let ws = null;
let isRecording = false;
let isProcessing = false;
let audioContext = null;
let mediaStream = null;
let analyser = null;
let recorder = null;
let audioChunks = [];
let history = [];
let reqId = 0;
let mode = 'ptt'; // ptt | wake | auto

// DOM
const $wsStatus = document.getElementById('wsStatus');
const $wsStatusText = document.getElementById('wsStatusText');
const $clusterMini = document.getElementById('clusterMini');
const $transcriptZone = document.getElementById('transcriptZone');
const $placeholder = document.getElementById('placeholder');
const $transcriptText = document.getElementById('transcriptText');
const $dominoResult = document.getElementById('dominoResult');
const $dominoName = document.getElementById('dominoName');
const $dominoCat = document.getElementById('dominoCat');
const $dominoSteps = document.getElementById('dominoSteps');
const $history = document.getElementById('history');
const $micBtn = document.getElementById('micBtn');
const $visualizer = document.getElementById('visualizer');
const $textInput = document.getElementById('textInput');
const $sendBtn = document.getElementById('sendBtn');

// ── VISUALIZER BARS ──
const BAR_COUNT = 24;
for (let i = 0; i < BAR_COUNT; i++) {
  const bar = document.createElement('div');
  bar.className = 'viz-bar';
  bar.style.height = '3px';
  $visualizer.appendChild(bar);
}
const vizBars = $visualizer.querySelectorAll('.viz-bar');

// ── WEBSOCKET ──
function connectWS() {
  $wsStatus.className = 'status-dot connecting';
  $wsStatusText.textContent = 'Connexion...';

  try {
    ws = new WebSocket(WS_URL);
  } catch(e) {
    $wsStatus.className = 'status-dot offline';
    $wsStatusText.textContent = 'Backend offline';
    setTimeout(connectWS, 5000);
    return;
  }

  ws.onopen = () => {
    $wsStatus.className = 'status-dot';
    $wsStatusText.textContent = 'Connecte';
  };

  ws.onmessage = (ev) => {
    try {
      const msg = JSON.parse(ev.data);
      handleWSMessage(msg);
    } catch(e) {}
  };

  ws.onclose = () => {
    $wsStatus.className = 'status-dot offline';
    $wsStatusText.textContent = 'Deconnecte';
    setTimeout(connectWS, 3000);
  };

  ws.onerror = () => {
    $wsStatus.className = 'status-dot offline';
    $wsStatusText.textContent = 'Erreur connexion';
  };
}

function wsSend(channel, action, payload = {}) {
  if (!ws || ws.readyState !== 1) return null;
  const id = `req_${++reqId}_${Date.now()}`;
  ws.send(JSON.stringify({ id, type: 'request', channel, action, payload }));
  return id;
}

function handleWSMessage(msg) {
  // Voice responses — only handle the response, ignore transcription_result event (avoids double)
  if (msg.type === 'response' && msg.channel === 'voice') {
    if (msg.action === 'stop_recording' && msg.payload) {
      onTranscriptionResult(msg.payload);
    }
  }
  if (msg.type === 'event' && msg.channel === 'voice') {
    if (msg.event === 'transcription_partial') {
      showTranscript(msg.payload.text, 'listening');
    }
    // transcription_result event ignored — response already handled above
  }

  // Chat responses — only handle the response, ignore agent_message event (avoids double)
  if (msg.type === 'response' && msg.channel === 'chat') {
    if (msg.payload && !msg.error) {
      onJarvisResponse(msg.payload);
    } else if (msg.error) {
      $jarvisResponse.classList.remove('thinking');
      $jarvisResponse.classList.add('show');
      $jarvisText.textContent = `Erreur: ${msg.error}`;
    }
  }
  if (msg.type === 'event' && msg.channel === 'chat') {
    // agent_message event ignored — response already handled above
    if (msg.event === 'agent_complete') {
      $jarvisResponse.classList.remove('thinking');
    }
  }

  // System command execution responses
  if (msg.type === 'response' && msg.channel === 'system') {
    if (msg.action === 'execute_command' && msg.payload) {
      $jarvisResponse.classList.remove('thinking');
      $jarvisResponse.classList.add('show');
      if (msg.payload.executed) {
        const desc = msg.payload.description || msg.payload.command_name;
        const output = msg.payload.output || '';
        const elapsed = msg.payload.elapsed || 0;
        $jarvisText.textContent = `${desc}\n${output}`.trim();
        // TTS confirmation
        if (!settings.silent) {
          const ttsText = cleanTextForTTS(desc);
          if (ttsText.length > 2) wsSend('voice', 'tts_speak', { text: ttsText });
        }
      } else if (msg.error || msg.payload.error) {
        $jarvisText.textContent = `Erreur: ${msg.error || msg.payload.error}`;
      }
    }
    if (msg.action === 'execute_domino' && msg.payload) {
      $jarvisResponse.classList.remove('thinking');
      $jarvisResponse.classList.add('show');
      if (msg.payload.executed) {
        const d = msg.payload.domino || {};
        $jarvisText.textContent = `Cascade ${d.domino_id || ''}: ${d.passed || 0} OK / ${d.failed || 0} FAIL (${d.total_ms || 0}ms)`;
      } else if (msg.payload.error) {
        $jarvisText.textContent = `Erreur domino: ${msg.payload.error}`;
      }
    }
  }

  // Cluster status (response or push event)
  if (msg.channel === 'cluster') {
    const nodes = msg.payload?.nodes || msg.payload?.status;
    if (nodes && typeof nodes === 'object') {
      for (const [name, info] of Object.entries(nodes)) {
        const key = name.toUpperCase();
        if (key in clusterState) {
          clusterState[key] = info?.online ?? info?.ok ?? (info === true);
        }
      }
      renderCluster();
    }
    if (Array.isArray(msg.payload)) {
      for (const n of msg.payload) {
        const key = (n.name || n.id || '').toUpperCase();
        if (key in clusterState) clusterState[key] = n.online ?? n.ok ?? true;
      }
      renderCluster();
    }
  }
}

// ── AUDIO RECORDING ──
async function startRecording() {
  if (isRecording || isProcessing) return;
  isRecording = true;
  audioChunks = [];
  $micBtn.classList.add('recording');
  $placeholder.style.display = 'none';
  $transcriptText.style.display = 'block';
  $dominoResult.classList.remove('show');
  showTranscript('Ecoute en cours...', 'listening');

  try {
    mediaStream = await navigator.mediaDevices.getUserMedia({
      audio: { sampleRate: 16000, channelCount: 1, echoCancellation: true, noiseSuppression: true }
    });

    audioContext = new AudioContext({ sampleRate: 16000 });
    const source = audioContext.createMediaStreamSource(mediaStream);
    analyser = audioContext.createAnalyser();
    analyser.fftSize = 256;
    source.connect(analyser);

    // MediaRecorder for chunks
    recorder = new MediaRecorder(mediaStream, { mimeType: 'audio/webm;codecs=opus' });
    recorder.ondataavailable = (e) => { if (e.data.size > 0) audioChunks.push(e.data); };
    recorder.start(250); // 250ms chunks

    // Notify backend
    wsSend('voice', 'start_recording');

    // Start visualizer
    updateVisualizer();

    // Stream chunks to backend
    streamAudioChunks();
  } catch(e) {
    console.error('Mic error:', e);
    showTranscript('Erreur microphone: ' + e.message, '');
    stopRecording();
  }
}

async function streamAudioChunks() {
  if (!isRecording) return;
  // Send pending chunks as base64
  while (audioChunks.length > 0) {
    const chunk = audioChunks.shift();
    const reader = new FileReader();
    reader.onload = () => {
      const base64 = reader.result.split(',')[1];
      wsSend('voice', 'audio_chunk', { audio: base64 });
    };
    reader.readAsDataURL(chunk);
  }
  if (isRecording) requestAnimationFrame(streamAudioChunks);
}

async function stopRecording() {
  if (!isRecording) return;
  isRecording = false;
  isProcessing = true;
  $micBtn.classList.remove('recording');
  $micBtn.classList.add('processing');
  showTranscript('Analyse en cours...', 'processing');

  if (recorder && recorder.state !== 'inactive') recorder.stop();
  if (mediaStream) mediaStream.getTracks().forEach(t => t.stop());

  // Request transcription
  wsSend('voice', 'stop_recording');

  // Timeout fallback
  setTimeout(() => {
    if (isProcessing) {
      isProcessing = false;
      $micBtn.classList.remove('processing');
      showTranscript('Timeout — reessaie', '');
    }
  }, 15000);
}

const $jarvisResponse = document.getElementById('jarvisResponse');
const $jarvisText = document.getElementById('jarvisText');

function onTranscriptionResult(data) {
  isProcessing = false;
  $micBtn.classList.remove('processing');

  // Extract text from transcription wrapper or direct data
  const tr = data.transcription || data;
  const text = tr.corrected || tr.original || tr.text || '';
  if (!text || text.length < 2) {
    showTranscript('(rien detecte)', '');
    return;
  }

  showTranscript(text, '');
  const domino = tr.domino || data.domino;
  const execution = tr.execution || data.execution;
  addHistory(text, domino);

  // Show domino match if found
  if (domino) {
    $dominoName.textContent = domino.id || domino;
    $dominoCat.textContent = domino.category ? `[${domino.category}]` : '';
    $dominoSteps.textContent = domino.description || '';
    $dominoResult.classList.add('show');
  }

  // If command was already executed by voice pipeline, show result
  if (execution && execution.executed) {
    $jarvisResponse.classList.remove('thinking');
    $jarvisResponse.classList.add('show');
    $jarvisText.textContent = execution.output || execution.description || 'Commande executee';
    // TTS confirmation
    if (!settings.silent) {
      const desc = execution.description || execution.command_name || '';
      const ttsText = cleanTextForTTS(desc);
      if (ttsText.length > 2) wsSend('voice', 'tts_speak', { text: ttsText });
    }
    return;
  }

  // No command executed — send to chat for IA response
  processCommand(text);
}

function executeCommand(domino) {
  // Execute matched command on the system
  $jarvisResponse.classList.add('show', 'thinking');
  $jarvisText.textContent = `Execution: ${domino.description || domino.id}...`;

  wsSend('system', 'execute_command', {
    command_name: domino.id,
    params: domino.params || {},
  });
}

function processCommand(text) {
  // Show thinking state
  $jarvisResponse.classList.add('show', 'thinking');
  $jarvisText.textContent = 'Reflexion...';

  // Send to chat channel
  wsSend('chat', 'send_message', { text: text.trim(), files: [] });
}

function cleanTextForTTS(text) {
  // Strip agent tags like [M1], [OL1], [M2], [M3], [GEMINI]
  let clean = text.replace(/\[(?:M[1-3]|OL1|GEMINI|CLAUDE)[^\]]*\]\s*/gi, '');
  // Strip markdown-style formatting
  clean = clean.replace(/[*_`#~]/g, '');
  // Strip brackets and parentheses
  clean = clean.replace(/[\[\](){}<>]/g, '');
  // Replace common punctuation with pauses or nothing
  clean = clean.replace(/[.!?;:]+/g, ', ');
  // Strip remaining symbols except letters, numbers, spaces, commas, hyphens, apostrophes
  clean = clean.replace(/[^a-zA-ZÀ-ÿ0-9\s,'\-éèêëàâäùûüîïôöçœæ]/g, '');
  // Collapse multiple spaces/commas
  clean = clean.replace(/,\s*,+/g, ',');
  clean = clean.replace(/\s{2,}/g, ' ');
  return clean.trim();
}

function onJarvisResponse(data) {
  $jarvisResponse.classList.remove('thinking');
  $jarvisResponse.classList.add('show');

  const agentMsg = data.agent_message;
  let responseText = '';
  if (agentMsg) {
    responseText = agentMsg.text || agentMsg.content || JSON.stringify(agentMsg);
  } else if (data.response) {
    responseText = data.response;
  } else if (typeof data === 'string') {
    responseText = data;
  } else {
    responseText = JSON.stringify(data);
  }

  // Clean up and display (full text with formatting)
  if (responseText.length > 500) responseText = responseText.slice(0, 500) + '...';
  $jarvisText.textContent = responseText || '(pas de reponse)';

  // TTS: read cleaned version aloud if not silent mode
  if (responseText && !settings.silent && responseText.length < 300) {
    const ttsText = cleanTextForTTS(responseText);
    if (ttsText.length > 2) {
      wsSend('voice', 'tts_speak', { text: ttsText });
    }
  }
}

// ── LOCAL WHISPER FALLBACK ──
// If WS backend is down, send audio directly to Whisper via fetch
async function localTranscribe(audioBlob) {
  showTranscript('Transcription locale...', 'processing');
  try {
    const formData = new FormData();
    formData.append('audio', audioBlob, 'recording.webm');
    // Try local whisper endpoint
    const resp = await fetch('http://127.0.0.1:9742/transcribe', {
      method: 'POST', body: formData
    });
    const data = await resp.json();
    onTranscriptionResult(data);
  } catch(e) {
    showTranscript('Backend offline — pas de transcription', '');
    isProcessing = false;
    $micBtn.classList.remove('processing');
  }
}

// ── TEXT COMMAND ──
function sendTextCommand(text) {
  if (!text.trim()) return;
  showTranscript(text, '');
  $placeholder.style.display = 'none';
  $transcriptText.style.display = 'block';
  $dominoResult.classList.remove('show');

  addHistory(text, null);
  $textInput.value = '';

  // Process via JARVIS (chat channel + show response)
  processCommand(text);
}

// ── DISPLAY ──
function showTranscript(text, state) {
  $transcriptText.textContent = text;
  $transcriptText.style.display = 'block';
  $placeholder.style.display = 'none';
  $transcriptText.className = 'transcript-text' + (state ? ' ' + state : '');
}

function addHistory(text, domino) {
  const now = new Date();
  const time = now.toTimeString().slice(0, 5);
  history.unshift({ text, domino, time });
  if (history.length > 20) history.pop();
  renderHistory();
}

function renderHistory() {
  $history.innerHTML = history.slice(0, 5).map(h => `
    <div class="history-item" onclick="showTranscript('${h.text.replace(/'/g,"\\'")}','')">
      <span class="history-time">${h.time}</span>
      <span class="history-text">${h.text}</span>
      ${h.domino ? `<span class="history-domino">${typeof h.domino === 'string' ? h.domino : h.domino.id || ''}</span>` : ''}
    </div>
  `).join('');
}

// ── VISUALIZER ──
function updateVisualizer() {
  if (!analyser || !isRecording) {
    vizBars.forEach(b => b.style.height = '3px');
    return;
  }
  const data = new Uint8Array(analyser.frequencyBinCount);
  analyser.getByteFrequencyData(data);

  const step = Math.floor(data.length / BAR_COUNT);
  for (let i = 0; i < BAR_COUNT; i++) {
    const val = data[i * step] || 0;
    const h = Math.max(3, (val / 255) * 32);
    vizBars[i].style.height = h + 'px';
  }
  requestAnimationFrame(updateVisualizer);
}

// ── CLUSTER STATUS (via WS backend to avoid CORS) ──
let clusterState = { M1: false, M2: false, OL1: false, M3: false };

async function checkCluster() {
  // If WS connected, ask backend for cluster status (no CORS issue)
  if (ws && ws.readyState === 1) {
    wsSend('cluster', 'get_status');
    // Response handled in handleWSMessage
  } else {
    // Fallback: try direct fetch (works in Electron, may fail in file://)
    for (const [name, node] of Object.entries(CLUSTER_NODES)) {
      try {
        const ctrl = new AbortController();
        setTimeout(() => ctrl.abort(), 2000);
        const r = await fetch(node.url, { signal: ctrl.signal, mode: 'no-cors' });
        clusterState[name] = true;
      } catch(e) { clusterState[name] = false; }
    }
  }
  renderCluster();
}

function renderCluster() {
  const html = [];
  for (const name of Object.keys(CLUSTER_NODES)) {
    const ok = clusterState[name];
    html.push(`<div class="node-dot"><div class="dot ${ok ? '' : 'off'}"></div>${name}</div>`);
  }
  $clusterMini.innerHTML = html.join('');
}

// ── KEYBOARD SHORTCUTS ──
let spaceDown = false;
document.addEventListener('keydown', (e) => {
  // Space = PTT (only when not typing)
  if (e.code === 'Space' && document.activeElement !== $textInput && !spaceDown) {
    e.preventDefault();
    spaceDown = true;
    startRecording();
  }
  // Escape = stop
  if (e.code === 'Escape') {
    if (isRecording) stopRecording();
  }
  // Enter in text input = send
  if (e.code === 'Enter' && document.activeElement === $textInput) {
    e.preventDefault();
    sendTextCommand($textInput.value);
  }
});

document.addEventListener('keyup', (e) => {
  if (e.code === 'Space' && spaceDown) {
    spaceDown = false;
    if (isRecording) stopRecording();
  }
});

// ── BUTTON HANDLERS ──
$micBtn.addEventListener('click', () => {
  if (isRecording) stopRecording();
  else if (!isProcessing) startRecording();
});

$sendBtn.addEventListener('click', () => sendTextCommand($textInput.value));

// Mode toggle
document.querySelectorAll('.mode-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    mode = btn.dataset.mode;
  });
});

// Pin toggle
let pinned = true;
document.getElementById('pinBtn').addEventListener('click', () => {
  pinned = !pinned;
  document.getElementById('pinBtn').style.color = pinned ? 'var(--accent)' : 'var(--dim)';
  if (window.electronAPI) window.electronAPI.setAlwaysOnTop(pinned);
});

// ── SETTINGS PANEL ──
const $settingsOverlay = document.getElementById('settingsOverlay');
const settings = { correction: true, sound: true, autoExec: false, silent: false };

document.getElementById('settingsBtn').addEventListener('click', () => {
  $settingsOverlay.classList.toggle('open');
});
document.getElementById('settingsClose').addEventListener('click', () => {
  $settingsOverlay.classList.remove('open');
});
$settingsOverlay.addEventListener('click', (e) => {
  if (e.target === $settingsOverlay) $settingsOverlay.classList.remove('open');
});

// Toggle switches
document.querySelectorAll('.toggle-switch').forEach(sw => {
  sw.addEventListener('click', () => {
    sw.classList.toggle('on');
    const key = sw.dataset.key;
    if (key) settings[key] = sw.classList.contains('on');
  });
});

// WS URL change
document.getElementById('setWsUrl').addEventListener('change', (e) => {
  const newUrl = e.target.value.trim();
  if (newUrl && newUrl !== WS_URL) {
    // Reconnect with new URL
    if (ws) ws.close();
    Object.defineProperty(window, '_wsUrl', { value: newUrl, writable: true });
  }
});

// ══════════════════════════════════════════════════════════════════
// DICTIONARY — 1931 commands + 88 pipelines + etoile.db
// ══════════════════════════════════════════════════════════════════
const $dictOverlay = document.getElementById('dictOverlay');
const $dictSearch = document.getElementById('dictSearch');
const $dictStats = document.getElementById('dictStats');
const $dictTabs = document.getElementById('dictTabs');
const $dictBody = document.getElementById('dictBody');

let dictData = null; // cached full dictionary
let dictFilter = 'all'; // current tab filter
let dictQuery = ''; // current search query

document.getElementById('dictBtn').addEventListener('click', () => {
  $dictOverlay.classList.toggle('open');
  if ($dictOverlay.classList.contains('open')) {
    $dictSearch.focus();
    if (!dictData) loadDictionary();
  }
});
document.getElementById('dictClose').addEventListener('click', () => {
  $dictOverlay.classList.remove('open');
});
$dictOverlay.addEventListener('click', (e) => {
  if (e.target === $dictOverlay) $dictOverlay.classList.remove('open');
});

// Search with debounce
let dictSearchTimeout;
$dictSearch.addEventListener('input', (e) => {
  clearTimeout(dictSearchTimeout);
  dictSearchTimeout = setTimeout(() => {
    dictQuery = e.target.value.trim().toLowerCase();
    renderDictionary();
  }, 200);
});

async function loadDictionary() {
  $dictBody.innerHTML = '<div class="dict-loading">Chargement du dictionnaire...</div>';
  try {
    const baseUrl = _loc.protocol === 'file:' ? 'http://127.0.0.1:9742' : '';
    const resp = await fetch(`${baseUrl}/api/dictionary`);
    const data = await resp.json();
    onDictionaryData(data);
  } catch(e) {
    $dictBody.innerHTML = `<div class="dict-empty">Erreur: ${e.message}</div>`;
  }
}

function onDictionaryData(payload) {
  dictData = payload;
  const s = payload.stats || {};
  $dictStats.innerHTML = [
    `<div class="dict-stat"><b>${s.commands||0}</b> commandes</div>`,
    `<div class="dict-stat"><b>${s.pipelines||0}</b> pipelines</div>`,
    `<div class="dict-stat"><b>${s.pipeline_dictionary||0}</b> dict DB</div>`,
    `<div class="dict-stat"><b>${s.domino_chains||0}</b> domino chains</div>`,
    `<div class="dict-stat"><b>${s.voice_corrections||0}</b> corrections</div>`,
  ].join('');

  // Build category tabs
  const cats = new Map();
  cats.set('all', 0);
  let total = 0;
  for (const c of (payload.commands || [])) {
    cats.set(c.category, (cats.get(c.category)||0) + 1);
    total++;
  }
  for (const p of (payload.pipelines || [])) {
    cats.set('pipeline:'+p.category, (cats.get('pipeline:'+p.category)||0) + 1);
    total++;
  }
  cats.set('all', total + (payload.pipeline_dictionary||[]).length);
  cats.set('db:dict', (payload.pipeline_dictionary||[]).length);
  cats.set('db:chains', (payload.domino_chains||[]).length);
  cats.set('db:corrections', (payload.voice_corrections||[]).length);

  const tabOrder = ['all'];
  // Top command categories
  const cmdCats = [...new Set((payload.commands||[]).map(c => c.category))].sort();
  tabOrder.push(...cmdCats);
  tabOrder.push('db:dict', 'db:chains', 'db:corrections');

  $dictTabs.innerHTML = tabOrder.map(cat => {
    const label = cat === 'all' ? 'Tout' :
                  cat === 'db:dict' ? 'Dict DB' :
                  cat === 'db:chains' ? 'Chains' :
                  cat === 'db:corrections' ? 'Corrections' :
                  cat.replace('pipeline:','P:');
    const count = cats.get(cat) || 0;
    return `<button class="dict-tab ${cat===dictFilter?'active':''}" data-cat="${cat}">${label}<span class="tab-count">${count}</span></button>`;
  }).join('');

  $dictTabs.querySelectorAll('.dict-tab').forEach(btn => {
    btn.addEventListener('click', () => {
      dictFilter = btn.dataset.cat;
      $dictTabs.querySelectorAll('.dict-tab').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      renderDictionary();
    });
  });

  renderDictionary();
}

function renderDictionary() {
  if (!dictData) return;
  const q = dictQuery;
  const f = dictFilter;
  let html = '';
  let count = 0;
  const MAX = 200;

  // Helper: match query
  function matches(item, fields) {
    if (!q) return true;
    for (const field of fields) {
      const val = item[field];
      if (!val) continue;
      if (Array.isArray(val)) {
        if (val.some(v => v.toLowerCase().includes(q))) return true;
      } else if (typeof val === 'string' && val.toLowerCase().includes(q)) {
        return true;
      }
    }
    return false;
  }

  // Commands
  if (f === 'all' || (!f.startsWith('db:') && !f.startsWith('pipeline:'))) {
    const cmds = (dictData.commands || []).filter(c => {
      if (f !== 'all' && c.category !== f) return false;
      return matches(c, ['name', 'description', 'triggers']);
    });
    if (cmds.length > 0) {
      html += `<div class="dict-section-title">Commandes (${cmds.length})</div>`;
      for (const c of cmds.slice(0, MAX - count)) {
        const triggers = (c.triggers||[]).slice(0,3).join(', ');
        html += `<div class="dict-item" data-exec-cmd="${c.name}">
          <div class="dict-item-icon cmd">${c.action_type ? c.action_type[0].toUpperCase() : 'C'}</div>
          <div class="dict-item-info">
            <div class="dict-item-name">${esc(c.name)}</div>
            <div class="dict-item-desc">${esc(c.description)}</div>
            <div class="dict-item-triggers">${esc(triggers)}</div>
          </div>
          <div class="dict-item-badge">${c.action_type||''}</div>
          <button class="dict-item-exec" title="Executer">&#x25B6;</button>
        </div>`;
        count++;
      }
    }
  }

  // Pipelines
  if ((f === 'all' || f.startsWith('pipeline:')) && count < MAX) {
    const pipes = (dictData.pipelines || []).filter(p => {
      if (f.startsWith('pipeline:') && p.category !== f.replace('pipeline:','')) return false;
      if (f === 'all' || f.startsWith('pipeline:')) return matches(p, ['id', 'description', 'trigger_vocal']);
      return false;
    });
    if (pipes.length > 0) {
      html += `<div class="dict-section-title">Pipelines (${pipes.length})</div>`;
      for (const p of pipes.slice(0, MAX - count)) {
        const triggers = (p.trigger_vocal||[]).slice(0,3).join(', ');
        html += `<div class="dict-item" data-exec-domino="${p.id}">
          <div class="dict-item-icon pipe">P</div>
          <div class="dict-item-info">
            <div class="dict-item-name">${esc(p.id)}</div>
            <div class="dict-item-desc">${esc(p.description)} (${p.steps} etapes)</div>
            <div class="dict-item-triggers">${esc(triggers)}</div>
          </div>
          <div class="dict-item-badge">${p.category||''}</div>
          <button class="dict-item-exec" title="Executer">&#x25B6;</button>
        </div>`;
        count++;
      }
    }
  }

  // DB: pipeline_dictionary
  if ((f === 'all' || f === 'db:dict') && count < MAX) {
    const dicts = (dictData.pipeline_dictionary || []).filter(d => {
      return matches(d, ['trigger_phrase', 'pipeline_id', 'category', 'steps']);
    });
    if (dicts.length > 0) {
      html += `<div class="dict-section-title">Pipeline Dictionary DB (${dicts.length})</div>`;
      for (const d of dicts.slice(0, MAX - count)) {
        html += `<div class="dict-item" data-exec-text="${esc(d.trigger_phrase||'')}">
          <div class="dict-item-icon chain">D</div>
          <div class="dict-item-info">
            <div class="dict-item-name">${esc(d.trigger_phrase||d.pipeline_id||'')}</div>
            <div class="dict-item-desc">${esc(d.steps||'')} | ${esc(d.agents_involved||'')}</div>
          </div>
          <div class="dict-item-badge">${d.action_type||d.category||''}</div>
          <button class="dict-item-exec" title="Executer">&#x25B6;</button>
        </div>`;
        count++;
      }
    }
  }

  // DB: domino_chains
  if ((f === 'all' || f === 'db:chains') && count < MAX) {
    const chains = (dictData.domino_chains || []).filter(d => {
      return matches(d, ['trigger_cmd', 'next_cmd', 'description', 'condition']);
    });
    if (chains.length > 0) {
      html += `<div class="dict-section-title">Domino Chains DB (${chains.length})</div>`;
      for (const d of chains.slice(0, MAX - count)) {
        html += `<div class="dict-item">
          <div class="dict-item-icon chain">&#x26D3;</div>
          <div class="dict-item-info">
            <div class="dict-item-name">${esc(d.trigger_cmd||'')} &#x2192; ${esc(d.next_cmd||'')}</div>
            <div class="dict-item-desc">${esc(d.description||'')} ${d.condition?'['+d.condition+']':''}</div>
          </div>
          <div class="dict-item-badge">${d.auto?'auto':d.delay_ms+'ms'}</div>
        </div>`;
        count++;
      }
    }
  }

  // DB: voice_corrections
  if ((f === 'all' || f === 'db:corrections') && count < MAX) {
    const corrs = (dictData.voice_corrections || []).filter(d => {
      return matches(d, ['wrong', 'correct', 'category']);
    });
    if (corrs.length > 0) {
      html += `<div class="dict-section-title">Corrections Vocales DB (${corrs.length})</div>`;
      for (const d of corrs.slice(0, MAX - count)) {
        html += `<div class="dict-item">
          <div class="dict-item-icon corr">&#x270E;</div>
          <div class="dict-item-info">
            <div class="dict-item-name">"${esc(d.wrong||'')}" &#x2192; "${esc(d.correct||'')}"</div>
            <div class="dict-item-desc">${d.category||''} | hits: ${d.hit_count||0}</div>
          </div>
        </div>`;
        count++;
      }
    }
  }

  if (!html) {
    html = '<div class="dict-empty">Aucun resultat</div>';
  }

  $dictBody.innerHTML = html;

  // Attach click handlers for execution
  $dictBody.querySelectorAll('[data-exec-cmd]').forEach(el => {
    el.addEventListener('click', () => {
      const cmdName = el.dataset.execCmd;
      $dictOverlay.classList.remove('open');
      $jarvisResponse.classList.add('show', 'thinking');
      $jarvisText.textContent = `Execution: ${cmdName}...`;
      wsSend('system', 'execute_command', { command_name: cmdName, params: {} });
    });
  });
  $dictBody.querySelectorAll('[data-exec-domino]').forEach(el => {
    el.addEventListener('click', () => {
      const dominoId = el.dataset.execDomino;
      $dictOverlay.classList.remove('open');
      $jarvisResponse.classList.add('show', 'thinking');
      $jarvisText.textContent = `Cascade: ${dominoId}...`;
      wsSend('system', 'execute_domino', { domino_id: dominoId });
    });
  });
  $dictBody.querySelectorAll('[data-exec-text]').forEach(el => {
    el.addEventListener('click', () => {
      const text = el.dataset.execText;
      $dictOverlay.classList.remove('open');
      processCommand(text);
    });
  });
}

function esc(s) {
  if (!s) return '';
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

// ── INIT ──
connectWS();
checkCluster();
setInterval(checkCluster, 15000);

// ── ELECTRON BRIDGE (if running in Electron) ──
if (window.electronAPI) {
  document.getElementById('minimizeBtn').addEventListener('click', () => window.electronAPI.minimize());
} else {
  document.getElementById('minimizeBtn').style.display = 'none';
}
</script>
</body>
</html>
